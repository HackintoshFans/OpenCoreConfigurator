
/* Class = "NSButtonCell"; title = "AppleImageConversion"; ObjectID = "0AM-nb-Yrd"; */
"0AM-nb-Yrd.title" = "AppleImageConversion";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple audio protocols with builtin versions.\nApple audio protocols allow macOS bootloader and OpenCore to play sounds and signals for screen reading or\naudible error reporting. Supported protocols are beep generation and VoiceOver. VoiceOver protocol is specific to Gibraltar machines (T2) and is not supported before macOS High Sierra (10.13). Instead older macOS versions use AppleHDA protocol, which is currently not implemented.\n\nOnly one set of audio protocols can be available at a time, so in order to get audio playback in OpenCore user interface on Mac system implementing some of these protocols this setting should be enabled.\n\nNote: Backend audio driver needs to be configured in UEFI Audio section for these protocols to be able to stream audio."; ObjectID = "0RZ-LX-aI2"; */
"0RZ-LX-aI2.ibShadowedToolTip" = "Réinstallez Apple Audio Protocol avec la version intégrée. \n Le protocole audio Apple permet au chargeur de démarrage macOS et à OpenCore de lire des sons et des signaux pour la lecture d'écran ou le signalement des erreurs sonores. \n Les protocoles pris en charge sont la génération de bips et VoiceOver. Non pris en charge avant macOS High Sierra (10.13). En revanche, les versions antérieures de macOS utilisaient le protocole AppleHDA, qui n'est pas actuellement implémenté. \n  \n Pour obtenir la lecture audio dans l'interface utilisateur OpenCore sur les systèmes Mac qui implémentent certains protocoles, ce paramètre doit être activé. \n  \n Remarque: vous devez configurer le pilote audio principal dans la section UEFI-> Audio pour que ces protocoles fonctionnent.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: NO\nDescription: Select firmwares, namely APTIO IV, may contain invalid values in MSR_FLEX_RATIO (0x194) MSR register. These values may cause macOS boot failure on Intel platforms.\nNote: While the option is not supposed to induce harm on unaffected firmwares, its usage is not recommended when it is not required."; ObjectID = "0Sc-nS-2YL"; */
"0Sc-nS-2YL.ibShadowedToolTip" = "Si vous n'avez pas déverrouillé CFG dans le bios, assurez-vous de sélectionner OUI.";

/* Class = "NSTextFieldCell"; title = "AudioDevice"; ObjectID = "0gM-HU-fz5"; */
"0gM-HU-fz5.title" = "AudioDevice";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Attempts to perform TSC synchronisation with a specified timeout.\nThe primary purpose of this quirk is to enable early bootstrap TSC synchronisation on some server and laptop models when running a debug XNU kernel. For the debug kernel the TSC needs to be kept in sync across the cores before any kext could kick in rendering all other solutions problematic. The timeout is specified in microseconds and depends on the amount of cores present on the platform, the recommended starting value is 500000.\nThis is an experimental quirk, which should only be used for the aforementioned problem. In all other cases the quirk may render the operating system unstable and is not recommended. The recommended solution in the other cases is to install a kernel driver like VoodooTSCSync, TSCAdjustReset, or CpuTscSync (a more specialised variant of VoodooTSCSync for newer laptops).\n\nNote: The reason this quirk cannot replace the kernel driver is because it cannot operate in ACPI S3 mode (sleep wake) and because the UEFI firmwares provide very limited multicore support preventing the precise update of the MSR registers."; ObjectID = "0un-PF-SFE"; */
"0un-PF-SFE.ibShadowedToolTip" = "Type: entier plist \nFailsafe: 0 \nDescription: tente d'effectuer la synchronisation TSC avec un délai spécifié. \nLe but principal de cette bizarrerie est d'activer la synchronisation TSC bootstrap précoce sur certains modèles de serveur et d'ordinateur portable lors de l'exécution d'un noyau de débogage XNU. Pour le noyau de débogage, le TSC doit être synchronisé entre les cœurs avant que n'importe quel kext ne puisse rendre problématique toutes les autres solutions. Le délai d'expiration est spécifié en microsecondes et dépend de la quantité de cœurs présents sur la plate-forme, la valeur de départ recommandée est 500000. \nCeci est une bizarrerie expérimentale, qui ne devrait être utilisée que pour le problème susmentionné. Dans tous les autres cas, la bizarrerie peut rendre le système d'exploitation instable et n'est pas recommandée. La solution recommandée dans les autres cas consiste à installer un pilote de noyau comme VoodooTSCSync, TSCAdjustReset ou CpuTscSync (une variante plus spécialisée de VoodooTSCSync pour les ordinateurs portables plus récents). \n \nRemarque: la raison pour laquelle cette bizarrerie ne peut pas remplacer le pilote du noyau est parce qu'elle ne peut pas fonctionner en mode ACPI S3 (veille de veille) et parce que les firmwares UEFI fournissent un support multicœur très limité empêchant la mise à jour précise des registres MSR.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Play chime sound at startup.\n\nEnabling this setting plays boot chime through builtin audio support. Volume level is determined by MinimumVolume and VolumeAmplifier settings and SystemAudioVolume NVRAM variable.\n\nNote: this setting is separate from StartupMute NVRAM variable to avoid conflicts when the firmware is able to play boot chime."; ObjectID = "10Z-Yt-6vt"; */
"10Z-Yt-6vt.ibShadowedToolTip" = "Jouez le bip de Duang au démarrage. \n Remarque: ce paramètre est distinct de la variable StartupMute NVRAM pour éviter les conflits lorsque le micrologiciel peut lire la sonnerie de démarrage.";

/* Class = "NSButtonCell"; title = "EnableJumpstart"; ObjectID = "133-jD-qYy"; */
"133-jD-qYy.title" = "EnableJumpstart";

/* Class = "NSButtonCell"; title = "DeduplicateBootOrder"; ObjectID = "1BB-1W-mfl"; */
"1BB-1W-mfl.title" = "DeduplicateBootOrder";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reconnect console controllers after changing screen resolution.\nOn some firmwares when screen resolution is changed via GOP, it is required to reconnect the controllers, which produce the console protocols (simple text out). Otherwise they will not produce text based on the new resolution.\nNote: On several boards this logic may result in black screen when launching OpenCore from Shell and thus it is optional. In versions prior to 0.5.2 this option was mandatory and not configurable. Please do not use this unless required."; ObjectID = "1QT-lu-i79"; */
"1QT-lu-i79.ibShadowedToolTip" = "Certains micrologiciels nécessitent de reconnecter le contrôleur pour afficher le texte après la modification de la résolution GOP. L'activation de cette option entraînera la disparition de l'écran lors du démarrage d'OpenCore à partir du shell UEFI. \n Si vous rencontrez un écran noir jusqu'à l'écran de connexion, veuillez essayer de sélectionner OUI.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Activate audio support by connecting to a backend driver.\n\nEnabling this setting routes audio playback from builtin protocols to a dedicated audio port (AudioOut) of the specified codec (AudioCodec) located on the audio controller (AudioDevice)."; ObjectID = "2zI-kW-5dk"; */
"2zI-kW-5dk.ibShadowedToolTip" = "Activez la prise en charge audio en vous connectant à un pilote principal (vous devez ajouter le pilote AudioDxe.efi). \n  \n Activez ce paramètre pour router la lecture audio du protocole intégré vers le port audio dédié (AudioOut) du codec spécifié (AudioCodec) situé sur le contrôleur audio (AudioDevice).";

/* Class = "NSButtonCell"; title = "HashServices"; ObjectID = "33a-jy-EES"; */
"33a-jy-EES.title" = "HashServices";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Request redirect of all Boot prefixed variables from EFI_GLOBAL_VARIABLE_GUID to OC_VENDOR_VARIABLE_GUID.\nThis quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi. The quirk lets default boot entry preservation at times when firmwares delete incompatible boot entries. Simply said, you are required to enable this quirk to be able to reliably use Startup Disk preference pane in a firmware that is not compatible with macOS boot entries by design."; ObjectID = "3Q0-sm-ooL"; */
"3Q0-sm-ooL.ibShadowedToolTip" = "Activez cette option pour permettre une utilisation fiable du paramètre [disque de démarrage] dans le micrologiciel qui n'est pas compatible avec la conception d'entrée de démarrage macOS. \n Il est également lié à la mémorisation de la fonction d'entrée de démarrage par défaut, il est recommandé d'utiliser OUI";

/* Class = "NSTextFieldCell"; title = "TimerResolution"; ObjectID = "3Ql-TM-Oiv"; */
"3Ql-TM-Oiv.title" = "TimerResolution";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist string\nFailsafe: empty string\nDescription: Set OEM protocol used for internal pointer driver.\nCurrently the only supported variant is ASUS, using specialised protocol available on select Z87 and Z97 ASUS boards."; ObjectID = "3mi-sh-qNa"; */
"3mi-sh-qNa.ibShadowedToolTip" = "Généralement laissé vide \n Il utilise certains protocoles propriétaires disponibles sur les cartes ASUS Z87 et Z97.";

/* Class = "NSButtonCell"; title = "RequestBootVarRouting"; ObjectID = "4Eq-ma-JKy"; */
"4Eq-ma-JKy.title" = "RequestBootVarRouting";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forcibly reinstalls unicode collation services with builtin version. Should be set to true to ensure UEFI Shell compatibility on platforms providing broken unicode collation. In general legacy Insyde and APTIO platforms on Ivy Bridge and earlier are affected."; ObjectID = "4bg-ao-G40"; */
"4bg-ao-G40.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Certains firmwares plus anciens rompent le classement Unicode. Le réglage sur YES peut corriger la compatibilité du shell UEFI sur ces systèmes (généralement pour IvyBridge ou des appareils plus anciens) ";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable internal keyboard input translation to AppleKeyMapAggregator protocol.\nThis option activates the internal keyboard interceptor driver, based on AppleGenericInput aka AptioIntput), to fill AppleKeyMapAggregator database for input functioning. In case a separate driver is used, such as OpenUsbKbDxe, this option should never be enabled."; ObjectID = "4fK-xq-9AN"; */
"4fK-xq-9AN.ibShadowedToolTip" = "Activez la prise en charge du clavier intégré d'OC. Certains ordinateurs portables ne peuvent pas utiliser le clavier dans l'interface du menu de démarrage. Veuillez le sélectionner! \n Si vous utilisez AppleUsbKbdxe.efi, veuillez définir NON";

/* Class = "NSTabViewItem"; label = "Audio"; ObjectID = "5Gm-fv-IpR"; */
"5Gm-fv-IpR.label" = "Audio";

/* Class = "NSButtonCell"; title = "JumpstartHotPlug"; ObjectID = "6B4-NA-lHR"; */
"6B4-NA-lHR.title" = "JumpstartHotPlug";

/* Class = "NSTableColumn"; headerCell.title = "Comment"; ObjectID = "6k6-uj-n97"; */
"6k6-uj-n97.headerCell.title" = "Commentaire";

/* Class = "NSTableView"; ibShadowedToolTip = "Type: plist array\nDefault value: None\nDescription: Load selected drivers from OC/Drivers directory.\nDesigned to be filled with string filenames meant to be loaded as UEFI drivers. Depending on the firmware a different set of drivers may be required. Loading an incompatible driver may lead your system to unbootable state or even cause permanent firmware damage. Some of the known drivers include:\n• AudioDxe — HDA audio support driver in UEFI firmwares for most Intel and some other analog audio controllers.\n• ExFatDxe — Proprietary ExFAT file system driver for Bootcamp support commonly found in Apple firmwares. For Sandy Bridge and earlier CPUs ExFatDxeLegacy driver should be used due to the lack of RDRAND instruction support.\n• HfsPlus — Proprietary HFS file system driver with bless support commonly found in Apple firmwares. For Sandy Bridge and earlier CPUs HfsPlusLegacy driver should be used due to the lack of RDRAND instruction support.\n• HiiDatabase* — HII services support driver from MdeModulePkg. This driver is included in most firmwares starting with Ivy Bridge generation. Some applications with the GUI like UEFI Shell may need this driver to work properly.\n• EnhancedFatDxe — FAT filesystem driver from FatPkg. This driver is embedded in all UEFI firmwares, and cannot be used from OpenCore. It is known that multiple firmwares have a bug in their FAT support implementation, which leads to corrupted filesystems on write attempt. Embedding this driver within the firmware may be required in case writing to EFI partition is needed during the boot process.\n• NvmExpressDxe — NVMe support driver from MdeModulePkg. This driver is included in most firmwares starting with Broadwell generation. For Haswell and earlier embedding it within the firmware may be more favourable in case a NVMe SSD drive is installed.\nOpenCanopy* — OpenCore plugin implementing graphical interface.\nOpenRuntime* — OpenCore plugin implementing OC_FIRMWARE_RUNTIME protocol.\n• OpenUsbKbDxe* — USB keyboard driver adding the support of AppleKeyMapAggregator protocols on top of a custom USB keyboard driver implementation. This is an alternative to builtin KeySupport, which may work better or worse depending on the firmware.\n• Ps2KeyboardDxe* — PS/2 keyboard driver from MdeModulePkg. DuetPkg OpenDuetPkg and some firmwares may not include this driver, but it is necessary for PS/2 keyboard to work. Note, un- like OpenUsbKbDxe this driver has no AppleKeyMapAggregator support and thus requires KeySupport to be enabled.\n• Ps2MouseDxe* — PS/2 mouse driver from MdeModulePkg. Some very old laptop firmwares may not include this driver, but it is necessary for touchpad to work in UEFI graphical interfaces, such as OpenCanopy.\n• UsbMouseDxe* — USB mouse driver from MdeModulePkg. Some virtual machine firmwares like OVMF may not include this driver, but it is necessary for mouse to work in UEFI graphical interfaces, such as OpenCanopy.\n• VBoxHfs — HFS file system driver with bless support. This driver is an alternative to a closed source HfsPlus driver commonly found in Apple firmwares. While it is feature complete, it is approximately 3 times slower and is yet to undergo a security audit.\n• XhciDxe* — XHCI USB controller support driver from MdeModulePkg. This driver is included in most firmwares starting with Sandy Bridge generation. For earlier firmwares or legacy systems it may be used to support external USB 3.0 PCI cards.\n\nDriver marked with * are bundled with OpenCore. To compile the drivers from UDK (EDK II) use the same command you do normally use for OpenCore compilation, but choose a corresponding package:\ngit clone https://github.com/acidanthera/audk UDK cd UDK\nsource edksetup.sh\nmake -C BaseTools\nbuild -a X64 -b RELEASE -t XCODE5 -p FatPkg/FatPkg.dsc\nbuild -a X64 -b RELEASE -t XCODE5 -p MdeModulePkg/MdeModulePkg.dsc"; ObjectID = "6zo-Jl-Ryl"; */
"6zo-Jl-Ryl.ibShadowedToolTip" = "Chargez les pilotes sélectionnés à partir du répertoire OC / Drivers. \n Notez l'ordre de remplissage \n Selon le matériel, différents pilotes peuvent être nécessaires. Le chargement de pilotes incompatibles peut entraîner un démarrage impossible du système ou même endommager définitivement le micrologiciel. Certains pilotes connus incluent: \n  • Pilote de démarrage du système de fichiers ApfsDriverLoader-APFS. Ajout de la prise en charge des pilotes APFS intégrés dans le conteneur APFS amorçable du micrologiciel UEFI. \n  • FwRuntimeServices - Améliore la sécurité d'OpenCore et de Lilu en prenant en charge les variables NVRAM en lecture seule et en lecture seule. Certaines bizarreries (telles que RequestBootVarRouting) nécessitent ce pilote pour fonctionner correctement. En raison de la nature du pilote d'exécution en temps réel, qui s'exécute en parallèle avec le système d'exploitation cible, il ne peut pas être implémenté dans OpenCore lui-même, mais est fourni avec la distribution OpenCore. \n  • Pilote du système de fichiers EnhancedFatDxe-FatPkg FAT. Ce pilote est intégré à tous les micrologiciels UEFI et ne peut pas être utilisé à partir d'OpenCore. Comme nous le savons tous, il existe des erreurs dans la mise en œuvre de la prise en charge FAT pour divers micrologiciels, ce qui peut endommager le système de fichiers lors de la tentative d'écriture. Si la partition EFI doit être écrite pendant le processus de démarrage, il se peut que ce pilote doive être intégré dans le micrologiciel. \n  • Pilote de support NvmExpressDxe-NVMe de MdeModulePkg. Ce pilote est inclus dans la plupart des micrologiciels de la génération Broadwell. Pour Haswell et les versions antérieures, si un disque SSD NVMe est installé, il est préférable de l'intégrer dans le micrologiciel. \n  • Le pilote de clavier USB UsbKbDxe ajoute la prise en charge du protocole AppleKeyMapAggregator basé sur l'implémentation du pilote de clavier USB personnalisé. Il s'agit d'une alternative au KeySupport intégré. \n  • VBoxHfs-possède un pilote qui prend en charge le système de fichiers HFS. Ce pilote peut remplacer le pilote HFSPlus à source fermée communément trouvé dans le micrologiciel Apple. Bien que pleinement fonctionnel, il est environ trois fois plus lent et n'a pas encore fait l'objet d'audits de sécurité. \n  • Le contrôleur USB XHCI dans XhciDxe-MdeModulePkg prend en charge les pilotes. Ce pilote est inclus dans la plupart des micrologiciels de la génération Sandy Bridge. Pour les anciens micrologiciels ou les anciens systèmes, il peut être utilisé pour prendre en charge les cartes PCI USB 3.0 externes \n  • Module d'interface graphique tiers OC standard NdkBootPicker";

/* Class = "NSTextFieldCell"; title = "MinVersion"; ObjectID = "7Ns-yB-e5j"; */
"7Ns-yB-e5j.title" = "MinVersion";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Load embedded APFS drivers from APFS containers.\nAPFS EFI driver is bundled in all bootable APFS containers. This option performs loading of signed APFS drivers with respect to ScanPolicy. See more details in “EFI Jumpstart” section of Apple File System Reference."; ObjectID = "8Sc-F2-ONI"; */
"8Sc-F2-ONI.ibShadowedToolTip" = "Type: plist boolean \n Failsafe: false \n Description: charge les pilotes APFS intégrés à partir des conteneurs APFS. \n Le pilote EFS APFS est fourni dans tous les conteneurs APFS amorçables. Cette option effectue le chargement des pilotes APFS signés par rapport à ScanPolicy. Voir plus de détails dans la section «EFI Jumpstart» de la référence du système de fichiers Apple. ";

/* Class = "NSTabViewItem"; label = "ReservedMemory"; ObjectID = "8vC-O7-rpe"; */
"8vC-O7-rpe.label" = "ReservedMemory";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Perform UEFI controller connection after driver loading.\nThis option is useful for loading drivers following UEFI driver model, as they may not start by themselves. Examples of such drivers are filesystem or audio drivers. While effective, this option may not be necessary for drivers performing automatic connection, and may slightly slowdown the boot.\n\nNote: Some firmwares, made by Apple in particular, only connect the boot drive to speedup the boot process. Enable this option to be able to see all the boot options when having multiple drives."; ObjectID = "9f0-xd-rhT"; */
"9f0-xd-rhT.ibShadowedToolTip" = "Une fois le pilote chargé, effectuez la connexion du contrôleur UEFI. Cette option est utile pour charger des pilotes de système de fichiers, qui suivent généralement le modèle de pilote UEFI et peuvent ne pas démarrer d'eux-mêmes. Bien qu'efficace, cette option peut ne pas être nécessaire pour les pilotes qui effectuent des connexions automatiques et peut ralentir légèrement le démarrage.";

/* Class = "NSTextFieldCell"; title = "MinDate"; ObjectID = "9fO-yG-VWd"; */
"9fO-yG-VWd.title" = "MinDate";

/* Class = "NSButtonCell"; title = "FirmwareVolume"; ObjectID = "AW6-UR-4Ex"; */
"AW6-UR-4Ex.title" = "FirmwareVolume";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Codec address on the specified audio controller for audio support. Normally this contains first audio codec address on the builtin analog audio controller (HDEF). Audio codec addresses, e.g. 2, can be found in the debug log: \nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs) \nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\nAs an alternative this value can be obtained from IOHDACodecDevice class in I/O Registry containing it in IOHDACodecAddress field."; ObjectID = "AZW-9D-hq6"; */
"AZW-9D-hq6.ibShadowedToolTip" = "Adresse du codec sur le contrôleur audio spécifié pour la prise en charge audio. Habituellement, il contient l'adresse du premier codec audio sur le contrôleur audio analogique intégré (HDEF). L'adresse du codec audio, telle que 2, se trouve dans le journal de débogage: \n OCAU: 1/3 PciRoot (0x0) / Pci (0x1,0x0) / Pci (0x0,0x1) / VenMsg (<réduit>, 00000000) ( 4 sorties) \n OCAU: 2/3 PciRoot (0x0) / Pci (0x3,0x0) / VenMsg (<redaged>, 00000000) (1 sorties) \n OCAU: 3/3 PciRoot (0x0) / Pci (0x1B, 0x0) / VenMsg (<redaged>, 02000000) (7 sorties) \n  \n  Alternativement, cette valeur peut être obtenue à partir de la classe IOHDACodecDevice dans le logiciel de registre d'E / S, qui est contenue dans le champ IOHDACodecAddress.";

/* Class = "NSButtonCell"; title = "AppleUserInterfaceTheme"; ObjectID = "BvY-5w-QBw"; */
"BvY-5w-QBw.title" = "AppleUserInterfaceTheme";

/* Class = "NSButtonCell"; title = "Browse"; ObjectID = "CLg-lY-N26"; */
"CLg-lY-N26.title" = "Parcourir";

/* Class = "NSButtonCell"; title = "IgnoreInvalidFlexRatio"; ObjectID = "CWI-LU-4dW"; */
"CWI-LU-4dW.title" = "IgnoreInvalidFlexRatio";

/* Class = "NSButtonCell"; title = "AppleSmcIo"; ObjectID = "Ddl-D0-484"; */
"Ddl-D0-484.title" = "AppleSmcIo";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Swap Command and Option keys during submission.\nThis option may be useful for keyboard layouts with Option key situated to the right of Command key."; ObjectID = "EIc-ff-Thn"; */
"EIc-ff-Thn.ibShadowedToolTip" = "Commutez les touches Commande et Option, sélectionnez généralement NON";

/* Class = "NSTextFieldCell"; title = "KeySupportMode"; ObjectID = "EeU-wj-caf"; */
"EeU-wj-caf.title" = "KeySupportMode";

/* Class = "NSButtonCell"; title = "PointerSupport"; ObjectID = "Elq-pL-QTD"; */
"Elq-pL-QTD.title" = "PointerSupport";

/* Class = "NSTextFieldCell"; title = "VolumeAmplifier"; ObjectID = "En7-ww-Uj5"; */
"En7-ww-Uj5.title" = "VolumeAmplifier";

/* Class = "NSTextFieldCell"; title = "KeyForgetThreshold"; ObjectID = "ErN-ks-EzO"; */
"ErN-ks-EzO.title" = "KeyForgetThreshold";

/* Class = "NSTabViewItem"; label = "APFS"; ObjectID = "F1Q-I5-6w7"; */
"F1Q-I5-6w7.label" = "APFS";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple SMC I/O protocol with a builtin version.\nThis protocol replaces legacy VirtualSmc UEFI driver, and is compatible with any SMC kernel extension. \nHowever, in case FakeSMC kernel extension is used, manual NVRAM key variable addition may be needed."; ObjectID = "FPA-9t-OzA"; */
"FPA-9t-OzA.ibShadowedToolTip" = "La dernière version intègre le protocole VirtualSmc.efi. \n Utilisez cette option pour supprimer le fichier VirtualSmc.efi dans le répertoire des pilotes. \n Cependant, si vous utilisez l'extension du noyau FakeSMC, vous devrez peut-être ajouter manuellement la variable de clé NVRAM.";

/* Class = "NSButtonCell"; title = "ReplaceTabWithSpace"; ObjectID = "HIh-Oc-UT7"; */
"HIh-Oc-UT7.title" = "ReplaceTabWithSpace";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Hide verbose output from APFS driver.\nAPFS verbose output can be useful for debugging."; ObjectID = "HdB-KO-x50"; */
"HdB-KO-x50.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Hide verbose output from APFS driver.\nAPFS verbose output can be useful for debugging.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forcibly reinstalls Hash Services protocols with builtin versions. Should be set to true to ensure File Vault 2 compatibility on platforms providing broken SHA-1 hashing. Can be diagnosed by invalid cursor size with UIScale set to 02, in general platforms prior to APTIO V (Haswell and older) are affected."; ObjectID = "HpH-bP-96S"; */
"HpH-bP-96S.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Réparer le problème de taille de curseur de souris incorrecte lors de l'exécution de FileVault, défini sur OUI pour une meilleure compatibilité avec FileVault";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Image Conversion protocol with a builtin version."; ObjectID = "ILy-av-YYi"; */
"ILy-av-YYi.ibShadowedToolTip" = "Reconstruisez l'icône de la pomme, sélectionnez généralement NON.";

/* Class = "NSTabViewItem"; label = "Protocols"; ObjectID = "Ife-ug-MJ5"; */
"Ife-ug-MJ5.label" = "Substitutions de protocole";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Debug Log protocol with a builtin version."; ObjectID = "JLv-Tn-pJQ"; */
"JLv-Tn-pJQ.ibShadowedToolTip" = "Réinstallez le protocole Apple Debug Log avec une version intégrée.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: false\nDescription: Reinstalls Data Hub protocol with a builtin version. This will delete all previous properties if the protocol was already installed."; ObjectID = "KN0-dq-pSV"; */
"KN0-dq-pSV.ibShadowedToolTip" = "Reconstruisez le datahub, sélectionnez NON ici.";

/* Class = "NSTextFieldCell"; title = "AudioCodec"; ObjectID = "L2f-gE-rBP"; */
"L2f-gE-rBP.title" = "AudioCodec";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal allowed APFS driver date.\nAPFS driver date connects APFS driver with the calendar release date. Older versions of APFS drivers may contain unpatched vulnerabilities, which can be used to inflict harm on your computer. This option permits restricting APFS drivers to only recent releases.\n• 0 — require the default supported release date of APFS in OpenCore. The default release date will increase with time and thus this setting is recommended. Currently set to 2020/01/01.\n• -1 — permit any release date to load (strongly discouraged).\n• Other — use custom minimal APFS release date, e.g. 20200401 for 2020/04/01. APFS release dates can be found in OpenCore boot log and OcApfsLib."; ObjectID = "L9i-6i-Mis"; */
"L9i-6i-Mis.ibShadowedToolTip" = "Type: entier plist \n Failsafe: 0 \n Description: Date de pilote APFS minimale autorisée. \n La date de pilote APFS connecte le pilote APFS à la date de sortie du calendrier. Les versions plus anciennes des pilotes APFS peuvent contenir des vulnérabilités non corrigées, qui peuvent être utilisées pour endommager votre ordinateur. Cette option permet de restreindre les pilotes APFS aux seules versions récentes. \n  • 0 - nécessite la date de sortie prise en charge par défaut d'APFS dans OpenCore. La date de sortie par défaut augmentera avec le temps et ce paramètre est donc recommandé. Actuellement défini sur 2020/01/01. \n  • -1 - autorise le chargement de toute date de sortie (fortement déconseillé). \n  • Autre - utilisez une date de sortie APFS minimale personnalisée, par exemple 20200401 pour 2020/04/01. Les dates de sortie d'APFS peuvent être trouvées dans le journal de démarrage d'OpenCore et OcApfsLib.";

/* Class = "NSButtonCell"; title = "OSInfo"; ObjectID = "Ljq-q2-IwF"; */
"Ljq-q2-IwF.title" = "OSInfo";

/* Class = "NSButtonCell"; title = "DataHub"; ObjectID = "NGa-cY-Uzn"; */
"NGa-cY-Uzn.title" = "DataHub";

/* Class = "NSTextFieldCell"; title = "Resolution"; ObjectID = "NbU-Qi-Xhw"; */
"NbU-Qi-Xhw.title" = "Résolution de la console";

/* Class = "NSButtonCell"; title = "KeyFiltering"; ObjectID = "Of8-Ba-FhQ"; */
"Of8-Ba-FhQ.title" = "KeyFiltering";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal heard volume level from 0 to 100.\n\nScreen reader will use this volume level, when the calculated volume level is less than MinimumVolume. Boot chime sound will not play if the calculated volume level is less than MinimumVolume."; ObjectID = "PF5-bc-9Z2"; */
"PF5-bc-9Z2.ibShadowedToolTip" = "Le volume minimum est compris entre 0 et 100. \n  \n Lorsque le niveau de volume calculé est inférieur à MinimumVolume, le lecteur d'écran utilisera ce niveau de volume. Si le volume calculé est inférieur à MinimumVolume, aucune tonalité de démarrage ne retentira.";

/* Class = "NSButtonCell"; title = "AppleAudio"; ObjectID = "POq-ge-Ugg"; */
"POq-ge-Ugg.title" = "AppleAudio";

/* Class = "NSBox"; title = "Quirks"; ObjectID = "PVa-Cc-beC"; */
"PVa-Cc-beC.title" = "Quirks";

/* Class = "NSTextFieldCell"; title = "TextRenderer"; ObjectID = "QQF-qM-yZS"; */
"QQF-qM-yZS.title" = "TextRenderer(Rendu de texte)";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: false\nDescription: Attempt to detach USB controller ownership from the firmware driver. While most firmwares manage to properly do that, or at least have an option for, select firmwares do not. As a result, operating system may freeze upon boot. Not recommended unless required."; ObjectID = "TTJ-UT-Xng"; */
"TTJ-UT-Xng.ibShadowedToolTip" = "La plupart des cartes mères ont pour fonction de libérer automatiquement la propriété USB. Nous choisissons NON. Si votre clavier et votre souris sont bloqués ou que la clé USB échoue, essayez de choisir Oui.";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: empty string\nDescription: Set internal keyboard input translation to AppleKeyMapAggregator protocol mode.\n• Auto — Performs automatic choice as available with the following preference: AMI, V2, V1.\n• V1 — Uses UEFI standard legacy input protocol EFI_SIMPLE_TEXT_INPUT_PROTOCOL.\n• V2 — Uses UEFI standard modern input protocol EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.\n• AMI — Uses APTIO input protocol AMI_EFIKEYCODE_PROTOCOL.\n\nNote: Currently V1, V2, and AMI unlike Auto only do filtering of the particular specified protocol. This may change in the future versions."; ObjectID = "TTL-Rn-Avg"; */
"TTL-Rn-Avg.ibShadowedToolTip" = "Auto: mode de protocole de conversion de valeurs-clés \n V1: protocole d'entrée hérité UEFI \n V2: nouveau protocole d'entrée UEFI \n AMI: protocole d'entrée APTIO";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal allowed APFS driver version.\nAPFS driver version connects APFS driver with the macOS release. APFS drivers from older macOS releases will become unsupported and thus may contain unpatched vulnerabilities, which can be used to inflict harm on your computer. This option permits restricting APFS drivers to only modern macOS versions.\n• 0 — require the default supported version of APFS in OpenCore. The default version will increase with time and thus this setting is recommended. Currently set to the latest point release from High Sierra.\n• -1 — permit any version to load (strongly discouraged).\n• Other — use custom minimal APFS version, e.g. 1412101001000000 from macOS Catalina 10.15.4. APFS versions can be found in OpenCore boot log and OcApfsLib."; ObjectID = "TYZ-jG-lfr"; */
"TYZ-jG-lfr.ibShadowedToolTip" = "Type: entier plist \n Failsafe: 0 \n Description: Version minimale autorisée du pilote APFS. \n La version du pilote APFS connecte le pilote APFS à la version macOS. Les pilotes APFS des anciennes versions de macOS ne seront plus pris en charge et peuvent donc contenir des vulnérabilités non corrigées, qui peuvent être utilisées pour endommager votre ordinateur. Cette option permet de limiter les pilotes APFS aux seules versions modernes de macOS. \n  • 0 - nécessite la version prise en charge par défaut d'APFS dans OpenCore. La version par défaut augmentera avec le temps et ce paramètre est donc recommandé. Actuellement défini sur la dernière version ponctuelle de High Sierra. \n  • -1 - autorise le chargement de toute version (fortement déconseillé). \n  • Autre - utilisez une version APFS minimale personnalisée, par exemple 1412101001000000 de macOS Catalina 10.15.4. Les versions APFS peuvent être trouvées dans le journal de démarrage OpenCore et OcApfsLib.";

/* Class = "NSButtonCell"; title = "ReleaseUsbOwnership"; ObjectID = "UMT-DK-9B5"; */
"UMT-DK-9B5.title" = "ReleaseUsbOwnership";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: false\nDescription: Reinstalls device property protocol with a builtin version. This will delete all previous properties if it was already installed. This may be used to ensure full compatibility on VMs or legacy Macs."; ObjectID = "Ueb-hn-jBT"; */
"Ueb-hn-jBT.ibShadowedToolTip" = "Sélectionnez généralement NO \n  pour garantir une compatibilité totale sur la machine virtuelle ou la vieille pomme blanche.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Index of the output port of the specified codec starting from 0.\nNormally this contains the index of the green out of the builtin analog audio controller (HDEF). The number of output nodes (N) in the debug log (marked in bold):\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs) \n\nThe quickest way to find the right port is to bruteforce the values from 0 to N - 1."; ObjectID = "UrW-oc-0Oc"; */
"UrW-oc-0Oc.ibShadowedToolTip" = "Spécifiez l'index du port de sortie du codec, généralement à partir de 0. \n  \n Le moyen le plus rapide pour trouver le port correct est de forcer la valeur de 0 à N-1. N est le nombre d'index de port de sortie affichés dans le journal, tels que Il y a 3 sorties dans le journal, vous pouvez les essayer de 0 à 2.";

/* Class = "NSTabViewItem"; label = "Drivers"; ObjectID = "V9Z-z9-Ejd"; */
"V9Z-z9-Ejd.label" = "Pilote UEFI";

/* Class = "NSButtonCell"; title = "AppleRtcRam"; ObjectID = "Xjp-N3-zFD"; */
"Xjp-N3-zFD.title" = "AppleRtcRam";

/* Class = "NSButtonCell"; title = "UnblockFsConnect"; ObjectID = "YFj-X6-x1j"; */
"YFj-X6-x1j.title" = "UnblockFsConnect";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist string\nFailsafe: empty string\nDescription: Device path of the specified audio controller for audio support.\nNormally this contains builtin analog audio controller (HDEF) device path, e.g. PciRoot(0x0)/Pci(0x1b,0x0).\nThe list of recognised audio controllers can be found in the debug log:\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\nAs an alternative gfxutil -f HDEF command can be used in macOS. Specifying empty device path will result in the first available audio controller to be used."; ObjectID = "YTE-Ba-80O"; */
"YTE-Ba-80O.ibShadowedToolTip" = "Chemin du périphérique pour le contrôleur audio spécifié pour la prise en charge des fonctionnalités audio. \n Habituellement, il contient le chemin de périphérique du contrôleur audio analogique (HDEF) intégré, tel que: PciRoot (0x0) / Pci (0x1b, 0x0). \n Une liste de contrôleurs audio se trouve dans le journal de débogage: \n OCAU: 1 / 3 PciRoot (0x0) / Pci (0x1,0x0) / Pci (0x0,0x1) / VenMsg (<expurgé>, 00000000) (4 sorties) \n OCAU: 2/3 PciRoot (0x0) / Pci (0x3,0x0) / VenMsg (<réduit>, 00000000) (1 sorties) \n OCAU: 3/3 PciRoot (0x0) / Pci (0x1B, 0x0) / VenMsg (<redigned>, 02000000) (7 sorties) \n  \n Également disponible sur Sous macOS, utilisez la commande gfxutil -f HDEF pour obtenir ou afficher l'adresse du périphérique audio à l'aide de l'outil Hackintool. Si vous spécifiez un chemin de périphérique vide, le premier contrôleur audio disponible sera utilisé.";

/* Class = "NSButtonCell"; title = "UnicodeCollation"; ObjectID = "ZCa-Hx-UFl"; */
"ZCa-Hx-UFl.title" = "UnicodeCollation";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Use builtin graphics output protocol renderer for console.\nOn some firmwares this may provide better performance or even fix rendering issues, but in general it is recommended not to use this option unless there is obvious benefit."; ObjectID = "a3V-hG-HCC"; */
"a3V-hG-HCC.ibShadowedToolTip" = "Utilisez le rendu du protocole de sortie graphique intégré comme console. \n Sur certains micrologiciels, cela peut offrir de meilleures performances et même résoudre les problèmes de rendu, mais il est généralement recommandé de ne pas utiliser cette option, sauf en cas d'avantage évident.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Event protocol with a builtin version. This may be used to ensure File Vault 2 compatibility on VMs or legacy Macs."; ObjectID = "aUv-Bv-xUd"; */
"aUv-Bv-xUd.ibShadowedToolTip" = "Requis pour les machines virtuelles avec des macs de coffre-fort. Sélectionnez NON.";

/* Class = "NSTextFieldCell"; title = "PointerSupportMode"; ObjectID = "anR-lZ-CjV"; */
"anR-lZ-CjV.title" = "PointerSupportMode";

/* Class = "NSButtonCell"; title = "ProvideConsoleGop"; ObjectID = "bdr-Pu-Crr"; */
"bdr-Pu-Crr.title" = "ProvideConsoleGop";

/* Class = "NSTextFieldCell"; title = "Multiple selection allowed"; ObjectID = "cNF-Pq-AYe"; */
"cNF-Pq-AYe.title" = "Choix multiples autorisés";

/* Class = "NSButtonCell"; title = "KeySupport"; ObjectID = "cia-MM-Epa"; */
"cia-MM-Epa.title" = "KeySupport";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some firmwares do not print tab characters or even everything that follows them, causing difficulties or inability to use the UEFI Shell builtin text editor to edit property lists and other documents. This option makes the console output spaces instead of tabs.\n\nNote: This option only applies to System renderer."; ObjectID = "dDZ-Zb-RKY"; */
"dDZ-Zb-RKY.ibShadowedToolTip" = "Certains firmwares ne peuvent pas imprimer les onglets, ni même tout ce qui se trouve après les onglets, ce qui rend difficile, voire impossible, l'utilisation de l'éditeur de texte intégré au shell UEFI pour modifier les listes de propriétés et autres documents. Cette option entraîne le remplacement des onglets par l'espace de sortie de la console. \n Remarque: cette option fonctionne uniquement avec le rendu système.";

/* Class = "NSButtonCell"; title = "SanitiseClearScreen"; ObjectID = "dXN-AE-igp"; */
"dXN-AE-igp.title" = "SanitiseClearScreen";

/* Class = "NSButtonCell"; title = "AppleBootPolicy"; ObjectID = "ddJ-by-qVm"; */
"ddJ-by-qVm.title" = "AppleBootPolicy";

/* Class = "NSButtonCell"; title = "AppleKeyMap"; ObjectID = "dpz-CS-4eq"; */
"dpz-CS-4eq.title" = "AppleKeyMap";

/* Class = "NSTextFieldCell"; title = "KeyMergeThreshold"; ObjectID = "du6-Wl-DOI"; */
"du6-Wl-DOI.title" = "KeyMergeThreshold";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable internal pointer driver.\nThis option implements standard UEFI pointer protocol (EFI_SIMPLE_POINTER_PROTOCOL) through select OEM protocols. The option may be useful on Z87 ASUS boards, where EFI_SIMPLE_POINTER_PROTOCOL is broken."; ObjectID = "dzp-p6-AHb"; */
"dzp-p6-AHb.ibShadowedToolTip" = "Si vous êtes un ASUS z87 ou z97, vous devez activer l'option PointerSupport.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Ensure GOP (Graphics Output Protocol) on console handle.\nmacOS bootloader requires GOP to be present on console handle, yet the exact location of GOP is not covered by the UEFI specification. This option will ensure GOP is installed on console handle if it is present.\n\nNote: This option will also replace broken GOP protocol on console handle, which may be the case on MacPro5,1 with newer GPUs."; ObjectID = "eGd-xS-rQf"; */
"eGd-xS-rQf.ibShadowedToolTip" = "Avant de sélectionner l'écran système, vous pouvez voir des informations sur votre erreur de configuration de configuration. Vous pouvez ajuster votre configuration en fonction de ces informations, ou vous pouvez choisir OUI pour ignorer. Il est recommandé de choisir OUI.";

/* Class = "NSButtonCell"; title = "HideVerbose"; ObjectID = "egr-8J-RIS"; */
"egr-8J-RIS.title" = "HideVerbose";

/* Class = "NSTextFieldCell"; title = "MinimumVolume"; ObjectID = "ehu-K3-gbY"; */
"ehu-K3-gbY.title" = "MinimumVolume";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Remove duplicate entries BootOrder variable in EFI_GLOBAL_VARIABLE_GUID.\n\nThis quirk requires RequestBootVarRouting to be enabled and therefore OC_FIRMWARE_RUNTIME protocol imple- mented in OpenRuntime.efi.\nBy redirecting Boot prefixed variables to a separate GUID namespace with the help of RequestBootVarRouting quirk we achieve multiple goals:\n• Operating systems are jailed and only controlled by OpenCore boot environment to enhance security.\n• Operating systems do not mess with OpenCore boot priority, and guarantee fluent updates and hibernation\nwakes for cases that require reboots with OpenCore in the middle.\n• Potentially incompatible boot entries, such as macOS entries, are not deleted or anyhow corrupted.\nHowever, some firmwares do their own boot option scanning upon startup by checking file presence on the available disks. Quite often this scanning includes non-standard locations, such as Windows Bootloader paths. Normally it is not an issue, but some firmwares, ASUS firmwares on APTIO V in particular, have bugs. For them scanning is implemented improperly, and firmware preferences may get accidentally corrupted due to BootOrder entry duplication (each option will be added twice) making it impossible to boot without cleaning NVRAM.\nTo trigger the bug one should have some valid boot options (e.g. OpenCore) and then install Windows with RequestBootVarRouting enabled. As Windows bootloader option will not be created by Windows installer, the firmware will attempt to create it itself, and then corrupt its boot option list.\nThis quirk removes all duplicates in BootOrder variable attempting to resolve the consequences of the bugs upon OpenCore loading. It is recommended to use this key along with BootProtect option."; ObjectID = "esT-oy-xWe"; */
"esT-oy-xWe.ibShadowedToolTip" = "Type: plist boolean \nFailsafe: false \nDescription: Supprimez les entrées en double Variable BootOrder dans EFI_GLOBAL_VARIABLE_GUID. \n \nCette bizarrerie nécessite l'activation de RequestBootVarRouting et donc le protocole OC_FIRMWARE_RUNTIME mis en œuvre dans les variables OpenRuntime.efi à \ préfixe OpenRuntime.efi. un espace de noms GUID séparé à l'aide de la requête RequestBootVarRouting, nous atteignons plusieurs objectifs: \n • Les systèmes d'exploitation sont emprisonnés et uniquement contrôlés par l'environnement de démarrage OpenCore pour améliorer la sécurité. \n • Les systèmes d'exploitation ne gâchent pas la priorité de démarrage d'OpenCore et garantissent des mises à jour fluides et hibernation \nprévoit pour les cas qui nécessitent un redémarrage avec OpenCore au milieu. \n • Les entrées de démarrage potentiellement incompatibles, telles que les entrées macOS, ne sont pas supprimées ni corrompues. \nCependant, certains firmwares effectuent leur propre option de démarrage lors du démarrage en vérifiant le fichier présence sur les disques disponibles. Souvent, cette analyse inclut des emplacements non standard, tels que les chemins d'accès du chargeur de démarrage Windows. Normalement, ce n'est pas un problème, mais certains firmwares, notamment les firmwares ASUS sur APTIO V, ont des bugs. Pour eux, la numérisation n'est pas implémentée correctement et les préférences du micrologiciel peuvent être accidentellement corrompues en raison de la duplication des entrées BootOrder (chaque option sera ajoutée deux fois), ce qui rend impossible le démarrage sans nettoyer la NVRAM. \nPour déclencher le bogue, il faut avoir des options de démarrage valides (par exemple OpenCore), puis installez Windows avec RequestBootVarRouting activé. Comme l'option de chargeur de démarrage Windows ne sera pas créée par le programme d'installation de Windows, le micrologiciel tentera de le créer lui-même, puis corrompra sa liste d'options de démarrage. \nCette bizarrerie supprime tous les doublons dans la variable BootOrder tentant de résoudre les conséquences des bogues lors du chargement d'OpenCore. Il est recommandé d'utiliser cette clé avec l'option BootProtect.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some firmwares reset screen resolution to a failsafe value (like 1024x768) on the attempts to clear screen contents when large display (e.g. 2K or 4K) is used. This option attempts to apply a workaround.\n\nNote: This option only applies to System renderer. On all known affected systems ConsoleMode had to be set to empty string for this to work."; ObjectID = "f0k-6s-W9I"; */
"f0k-6s-W9I.ibShadowedToolTip" = "Lorsque vous utilisez un grand écran (tel que 2K ou 4K), certains microprogrammes réinitialisent la résolution d'écran à une valeur de sécurité (telle que 1024x768) pour effacer le contenu de l'écran. Cette option tente d'appliquer la solution de contournement. \n Remarque: TextRenderer doit être défini sur le mode de rendu système pour qu'il prenne effet. Sur tous les systèmes affectés connus, ConsoleMode doit être défini sur une chaîne vide pour qu'il prenne effet.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Set architecture timer resolution.\nThis option allows to update firmware architecture timer period with the specified value in 100 nanosecond units. Setting a lower value generally improves performance and responsiveness of the interface and input handling.\nThe recommended value is 50000 (5 milliseconds) or slightly higher. Select ASUS Z87 boards use 60000 for the interface. Apple boards use 100000. You may leave it as 0 in case there are issues."; ObjectID = "fda-QM-Vl4"; */
"fda-QM-Vl4.ibShadowedToolTip" = "Fréquence d'actualisation de l'horloge du micrologiciel (unité: 100 nanosecondes) \n La carte mère NAS utilise 60000 pour son interface \n Apple utilise 100000";

/* Class = "NSTabViewItem"; label = "Output"; ObjectID = "gJG-UT-7D3"; */
"gJG-UT-7D3.label" = "Afficher la sortie liée";

/* Class = "NSButtonCell"; title = "KeySwap"; ObjectID = "h6b-rN-daY"; */
"h6b-rN-daY.title" = "KeySwap";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty string\nDescription: Sets console output screen resolution.\n• Set to WxH@Bpp (e.g. 1920x1080@32) or WxH (e.g. 1920x1080) formatted string to request custom resolution from GOP if available.\n• Set to empty string not to change screen resolution.\n• Set to Max to try to use largest available screen resolution.\nOn HiDPI screens APPLE_VENDOR_VARIABLE_GUID UIScale NVRAM variable may need to be set to 02 to enable HiDPI scaling in FileVault 2 UEFI password interface and boot screen logo. Refer to Recommended Variables section for more details.\nNote: This will fail when console handle has no GOP protocol. When the firmware does not provide it, it can be added with ProvideConsoleGop set to true."; ObjectID = "hVw-xH-z40"; Note = "Do Not Translate"; */
"hVw-xH-z40.ibShadowedToolTip" = "Définir la résolution d'écran de sortie de la console. \n  • Définir sur vide pour ne pas modifier la résolution d'écran. \n  • Définir sur Max pour essayer d'utiliser la plus grande résolution d'écran disponible. \n Remarque: si le descripteur de la console ne possède pas de protocole GOP, cela échouera. Vous pouvez définir la valeur True de ProviderConsoleGop pour l'ajouter.";

/* Class = "NSTableView"; ibShadowedToolTip = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Start address of the reserved memory region, which should be allocated as reserved effectively marking the memory of this type inaccessible to the operating system.\nThe addresses written here must be part of the memory map, have EfiConventionalMemory type, and page-aligned (4 KBs).\n2. Comment\nType: plist string\nFailsafe: Empty string\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used.\n3. Size\nType: plist integer\nFailsafe: 0\nDescription: Size of the reserved memory region, must be page-aligned (4 KBs).\n4. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This region will not be reserved unless set to true."; ObjectID = "hs4-gm-1Ct"; */
"hs4-gm-1Ct.ibShadowedToolTip" = "1. Adresse \nType: entier plist \nFailsafe: 0 \nDescription: Adresse de début de la région de mémoire réservée, qui doit être allouée comme réservée, ce qui marque efficacement la mémoire de ce type inaccessible au système d'exploitation. \nLes adresses écrites ici doivent faire partie de la carte mémoire, ont le type EfiConventionalMemory et sont alignés sur la page (4 Ko). \n2. Commentaire \nType: chaîne de plist \nFailsafe: chaîne vide \nDescription: chaîne ASCII arbitraire utilisée pour fournir une référence lisible par l'homme pour l'entrée. Il est défini par l'implémentation si cette valeur est utilisée. \n3. Taille \nType: entier plist \nFailsafe: 0 \nDescription: La taille de la zone de mémoire réservée doit être alignée sur la page (4 Ko). \n4. Activé \nType: plist boolean \nFailsafe: false \nDescription: Cette région ne sera pas réservée sauf si elle est définie sur true.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple User Interface Theme protocol with a builtin version."; ObjectID = "iFT-xW-ZaT"; */
"iFT-xW-ZaT.ibShadowedToolTip" = "Réinstallez le protocole de thème de l'interface utilisateur Apple à l'aide de la version intégrée.";

/* Class = "NSTextFieldCell"; title = "TscSyncTimeout"; ObjectID = "ifT-4Q-EvN"; */
"ifT-4Q-EvN.title" = "TscSyncTimeout";

/* Class = "NSView"; ibShadowedToolTip = "Type: plist array \nDescription: Designed to be filled with plist dict values, describing memory areas exquisite to particular firmware and hardware functioning, which should not be used by the operating system. An example of such\nmemory region could be second 256 MB corrupted by Intel HD 3000 or an area with faulty RAM. See Reserved-Memory Properties section below."; ObjectID = "k2W-U9-Ysu"; */
"k2W-U9-Ysu.ibShadowedToolTip" = "Type: tableau plist \nDescription: Conçu pour être rempli avec des valeurs dict plist, décrivant les zones de mémoire exquises pour un fonctionnement particulier du firmware et du matériel, qui ne doivent pas être utilisées par le système d'exploitation. Un exemple d'une telle région \nmemory pourrait être un second 256 Mo corrompu par Intel HD 3000 ou une zone avec une RAM défectueuse. Voir la section Propriétés de la mémoire réservée ci-dessous.";

/* Class = "NSButtonCell"; title = "AppleEvent"; ObjectID = "k4I-Ol-kq5"; */
"k4I-Ol-kq5.title" = "AppleEvent";

/* Class = "NSTextFieldCell"; title = "Console Mode"; ObjectID = "k5b-42-EPT"; */
"k5b-42-EPT.title" = "Console Mode";

/* Class = "NSButtonCell"; title = "Connect Drivers"; ObjectID = "kBk-75-acl"; */
"kBk-75-acl.title" = "Pilote de connexion";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Assume simultaneous combination for keys submitted within this timeout in milliseconds.\nSimilarly to KeyForgetThreshold, this option works around the sequential nature of key submission. To be able to recognise simultaneously pressed keys in the situation when all keys arrive sequentially, we are required to set a timeout within which we assume the keys were pressed together.\nHolding multiple keys results in reports every 2 and 1 milliseconds for VMware and APTIO V respectively. Pressing keys one after the other results in delays of at least 6 and 10 milliseconds for the same platforms. The recommended value for this option is 2 milliseconds, but it may be decreased for faster platforms and increased for slower."; ObjectID = "kKb-0m-i9e"; */
"kKb-0m-i9e.ibShadowedToolTip" = "Intervalle de temps (unité: millisecondes) auquel la clé est réinitialisée en appuyant sur la touche. Similaire à KeyForgetThreshold, cette option s'applique à la nature séquentielle de la soumission de la clé. Afin de pouvoir reconnaître les touches enfoncées simultanément lorsque toutes les touches arrivent dans l'ordre, nous devons définir un délai d'expiration pendant lequel nous supposons que les touches sont enfoncées simultanément. \n Le maintien de plusieurs clés signalera respectivement VMware et APTIOV toutes les 2 ms et 1 ms. Pour la même plateforme, le fait d'appuyer les touches l'une après l'autre provoque un retard d'au moins 6 à 10 millisecondes. La valeur recommandée pour cette option est de 2 millisecondes, mais elle peut diminuer pour les plates-formes plus rapides et augmenter pour les plates-formes plus lentes.";

/* Class = "NSTextFieldCell"; title = "AudioOut"; ObjectID = "kM6-tO-pns"; */
"kM6-tO-pns.title" = "AudioOut";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Load APFS drivers for newly connected devices.\nPerforms APFS driver loading not only at OpenCore startup but also during boot picker. This permits APFS USB hot plug. Disable if not required."; ObjectID = "kSG-eA-B2o"; */
"kSG-eA-B2o.ibShadowedToolTip" = "Type: plist boolean\n Failsafe: false\nDescription: Load APFS drivers for newly connected devices.\nPerforms APFS driver loading not only at OpenCore startup but also during boot picker. This permits APFS USB hot plug. Disable if not required.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forcibly reinstalls OS Info protocol with builtin versions. This protocol is generally used to receive notifications from macOS bootloader, by the firmware or by other applications."; ObjectID = "l9b-pk-oii"; */
"l9b-pk-oii.ibShadowedToolTip" = "Forcer la réinstallation du protocole OS Info à l'aide de la version intégrée. Ce protocole est généralement utilisé pour recevoir des notifications du chargeur de démarrage macOS, du micrologiciel ou d'autres applications \n Temporairement inutile, sélectionnez NON.";

/* Class = "NSTableColumn"; headerCell.title = "Address"; ObjectID = "ldi-uY-9wO"; */
"ldi-uY-9wO.headerCell.title" = "Adresse";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string \nFailsafe: Empty string \nDescription: Sets console output mode as specified with the WxH (e.g. 80x24) formatted string.\nSet to empty string not to change console mode. Set to Max to try to use largest available console mode. Currently Builtin text renderer supports only one console mode, so this option is ignored.\n\nNote: This field is best to be left empty on most firmwares."; ObjectID = "lye-vu-fi3"; Note = "Do Not Translate"; */
"lye-vu-fi3.ibShadowedToolTip" = "La définition d'une chaîne vide ne modifie pas le mode de la console. Définissez sur Max pour essayer d'utiliser le plus grand mode de console disponible. \n Dans la plupart des cas, laissez-le vide!";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: BuiltinGraphics\nDescription: Chooses renderer for text going through standard console output.\nCurrently two renderers are supported: Builtin and System. System renderer uses firmware services for text rendering. Builtin bypassing firmware services and performs text rendering on its own. Different renderers support a different set of options. It is recommended to use Builtin renderer, as it supports HiDPI mode and uses full screen resolution.\nUEFI firmwares generally support ConsoleControl with two rendering modes: Graphics and Text. Some firmwares do not support ConsoleControl and rendering modes. OpenCore and macOS expect text to only be shown in Graphics mode and graphics to be drawn in any mode. Since this is not required by UEFI specification, exact behaviour varies.\nValid values are combinations of text renderer and rendering mode:\n• BuiltinGraphics — Switch to Graphics mode and use Builtin renderer with custom ConsoleControl.\n• SystemGraphics — Switch to Graphics mode and use System renderer with custom ConsoleControl.\n• SystemText — Switch to Text mode and use System renderer with custom ConsoleControl.\n• SystemGeneric — Use System renderer with system ConsoleControl assuming it behaves correctly.\nThe use of BuiltinGraphics is generally straightforward. For most platforms it is necessary to enable ProvideConsoleGop, set Resolution to Max, and optionally configure Scale.\nThe use of System protocols is more complicated. In general the preferred setting is SystemGraphics or SystemText. Enabling ProvideConsoleGop, setting Resolution to Max, enabling ReplaceTabWithSpace is useful on almost all platforms. SanitiseClearScreen, IgnoreTextInGraphics, and ClearScreenOnModeSwitch are more specific, and their use depends on the firmware.\n\nNote: Some Macs, namely MacPro5,1, may have broken console output with newer GPUs, and thus only BuiltinGraphics may work for them."; ObjectID = "mlh-hW-OqT"; */
"mlh-hW-OqT.ibShadowedToolTip" = "Sélectionnez un rendu pour la sortie de texte via la console standard. \n Deux rendus sont actuellement pris en charge: intégré et système. Le rendu système utilise des services de micrologiciel pour le rendu de texte. La fonction intégrée contourne le service de micrologiciel et effectue le rendu de texte de son propre chef. Différents moteurs de rendu prennent en charge différents ensembles d'options. Il est recommandé d'utiliser le moteur de rendu intégré car il prend en charge le mode HiDPI et utilise une résolution plein écran. \n Le contenu de l'option est une combinaison de rendu de texte et de mode de rendu: \n  • BuiltinGraphics - passez en mode \"graphiques\" et utilisez le rendu intégré avec un ConsoleControl personnalisé. \n  • SystemGraphics-passez en mode \"graphiques\", puis Utilisez le rendu système avec un ConsoleControl personnalisé. \n  • SystemText - basculez en mode texte et utilisez le rendu système avec un ConsoleControl personnalisé. \n  • SystemGeneric - utilisez le rendu système avec le système ConsoleControl et supposez que son comportement est correct. \n BuiltinGraphics est généralement simple à utiliser. Pour la plupart des plates-formes, ProviderConsoleGop doit être activé, définir l'option de résolution sur Max et choisir de configurer Scale. \n L'utilisation des protocoles système est plus compliquée. Habituellement, le paramètre préféré est SystemGraphics ou SystemText. L'activation de ProviderConsoleGop, la définition de «Résolution» sur «Max» et l'activation de «ReplaceTabWithSpace» sont utiles sur presque toutes les plateformes. SanitiseClearScreen, IgnoreTextInGraphics et ClearScreenOnModeSwitch sont plus spécifiques et leur utilisation dépend du firmware. \n  \n Remarque: Certains modèles de Mac, tels que MacPro5,1, peuvent avoir une sortie de console corrompue sur des GPU plus récents, donc seuls BuiltinGraphics fonctionnera pour eux.";

/* Class = "NSTableColumn"; headerCell.title = "Enabled"; ObjectID = "n2P-We-NTM"; */
"n2P-We-NTM.headerCell.title" = "Activée";

/* Class = "NSButtonCell"; title = "DirectGopRendering"; ObjectID = "nIf-jD-bYP"; */
"nIf-jD-bYP.title" = "DirectGopRendering";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forcibly wraps Firmware Volume protocols or installs new to support custom cursor images for File Vault 2. Should be set to true to ensure File Vault 2 compatibility on everything but VMs and legacy Macs.\n\nNote: Several virtual machines including VMware may have corrupted cursor image in HiDPI mode and thus may also require this setting to be enabled."; ObjectID = "nvr-JF-3ne"; */
"nvr-JF-3ne.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Fixer les problèmes d'interface utilisateur avec Filevault, défini sur OUI pour une meilleure compatibilité avec FileVault";

/* Class = "NSButtonCell"; title = "DeviceProperties"; ObjectID = "oMi-yN-r8X"; */
"oMi-yN-r8X.title" = "DeviceProperties";

/* Class = "NSButtonCell"; title = "AudioSupport"; ObjectID = "oT1-Q2-rhc"; */
"oT1-Q2-rhc.title" = "AudioSupport";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some firmwares clear only part of screen when switching from graphics to text mode, leaving a fragment of previously drawn image visible. This option fills the entire graphics screen with black color before switching to text mode.\n\nNote: This option only applies to System renderer."; ObjectID = "qMh-AF-g0P"; */
"qMh-AF-g0P.ibShadowedToolTip" = "Lorsque le mode graphique passe en mode texte, certains micrologiciels n'effacent qu'une partie de l'écran, rendant visibles les fragments d'image précédemment dessinés. Cette option remplit tout l'écran graphique de noir avant de passer en mode texte. \n Remarque: cette option fonctionne uniquement avec le rendu système.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false \nDescription: Reinstalls Apple RTC RAM protocol with builtin version.\n\nNote: Builtin version of Apple RTC RAM protocol may filter out I/O attempts to select RTC memory addresses. \nThe list of addresses can be specified in 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist variable as a data array."; ObjectID = "r1b-ma-oOs"; */
"r1b-ma-oOs.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false \nDescription: Reinstalls Apple RTC RAM protocol with builtin version.\n\nNote: Builtin version of Apple RTC RAM protocol may filter out I/O attempts to select RTC memory addresses. \nThe list of addresses can be specified in 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist variable as a data array.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: false\nDescription: Reinstalls apple boot policy protocol with a builtin version. This may be used to ensure APFS compatibility on VMs or legacy Macs.\n\nNote: Some Macs, namely MacPro5,1, do have APFS compatibility, but their Apple Boot Policy protocol contains recovery detection issues, thus using this option is advised on them as well."; ObjectID = "rMl-Kr-h3I"; */
"rMl-Kr-h3I.ibShadowedToolTip" = "Il est utilisé pour assurer la compatibilité APFS sur les machines virtuelles ou les vieilles pommes blanches. En règle générale, sélectionnez NON.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Multiplication coefficient for system volume to raw volume linear translation from 0 to 1000.\nVolume level range read from SystemAudioVolume varies depending on the codec. To transform read value in [0, 127] range into raw volume range [0, 100] the read value is scaled to VolumeAmplifier percents.\n\nNote: the transformation used in macOS is not linear, but it is very close and this nuance is thus ignored."; ObjectID = "rNr-97-fnH"; */
"rNr-97-fnH.ibShadowedToolTip" = "Un multiple de la conversion linéaire du volume du système au volume d'origine, compris entre 0 et 1000. \n  \n  \n Remarque: Les transformations utilisées dans macOS ne sont pas linéaires, mais sont très proches, donc les nuances sont ignorées.";

/* Class = "NSButtonCell"; title = "PlayChime"; ObjectID = "rUJ-JZ-9dQ"; */
"rUJ-JZ-9dQ.title" = "PlayChime";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable keyboard input sanity checking.\nApparently some boards like GA Z77P-D3 may return uninitialised data in EFI_INPUT_KEY with all input protocols. This option discards keys that are neither ASCII, nor are defined in the UEFI specification (see tables 107 and 108 in version 2.8)."; ObjectID = "rxJ-TB-rJc"; */
"rxJ-TB-rJc.ibShadowedToolTip" = "Activez le contrôle d'intégrité du clavier.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Key Map protocols with builtin versions."; ObjectID = "tY1-cE-XtN"; */
"tY1-cE-XtN.ibShadowedToolTip" = "Reconstruisez la touche de fonction Apple et sélectionnez NON.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Select firmwares output text onscreen in both graphics and text mode. This is normally unexpected, because random text may appear over graphical images and cause UI corruption. Setting this option to true will discard all text output when console control is in mode different from Text.\n\nNote: This option only applies to System renderer."; ObjectID = "tgx-cE-NIf"; */
"tgx-cE-NIf.ibShadowedToolTip" = "Résoudre le problème de l'écrasement du journal de sortie sur le logo Apple lors du démarrage sans -v.";

/* Class = "NSTabViewItem"; label = "Input"; ObjectID = "tiX-oG-c7h"; */
"tiX-oG-c7h.label" = "Entrée";

/* Class = "NSButtonCell"; title = "ClearScreenOnModeSwitch"; ObjectID = "tqx-Ek-u4V"; */
"tqx-Ek-u4V.title" = "ClearScreenOnModeSwitch";

/* Class = "NSTableColumn"; headerCell.title = "Size"; ObjectID = "ufL-Er-oh9"; */
"ufL-Er-oh9.headerCell.title" = "Taille";

/* Class = "NSButtonCell"; title = "AppleDebugLog"; ObjectID = "uqk-49-YG8"; */
"uqk-49-YG8.title" = "AppleDebugLog";

/* Class = "NSTextFieldCell"; title = "ExitBootServicesDelay"; ObjectID = "wxD-TC-lrQ"; */
"wxD-TC-lrQ.title" = "ExitBootServicesDelay";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Remove key unless it was submitted during this timeout in milliseconds.\nAppleKeyMapAggregator protocol is supposed to contain a fixed length buffer of currently pressed keys. However, the majority of the drivers only report key presses as interrupts and pressing and holding the key on the keyboard results in subsequent submissions of this key with some defined time interval. As a result we use a timeout to remove once pressed keys from the buffer once the timeout expires and no new submission of this key happened.\nThis option allows to set this timeout based on your platform. The recommended value that works on the majority of the platforms is 5 milliseconds. For reference, holding one key on VMware will repeat it roughly every 2 milliseconds and the same value for APTIO V is 3-4 milliseconds. Thus it is possible to set a slightly lower value on faster platforms and slightly higher value on slower platforms for more responsive input."; ObjectID = "xNH-9V-3kd"; */
"xNH-9V-3kd.ibShadowedToolTip" = "Intervalle de temps entre chaque touche après l'avoir appuyée (unité: millisecondes) \n Cette option permet de définir ce délai en fonction de votre plateforme. Une valeur recommandée de 5 ms est disponible sur la plupart des plateformes. Pour référence, la détention d'une clé sur VMware se répète toutes les 2 millisecondes environ, tandis que la même valeur pour APTIO V est de 3 à 4 millisecondes. Par conséquent, vous pouvez définir une valeur légèrement inférieure sur une plateforme plus rapide et une valeur légèrement supérieure sur une plateforme plus lente pour améliorer la vitesse de réponse.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nDefault value: 0\nDescription: Adds delay in microseconds after EXIT_BOOT_SERVICES event.\nThis is a very ugly quirk to circumvent \"Still waiting for root device\" message on select APTIO IV firmwares, namely ASUS Z87-Pro, when using FileVault 2 in particular. It seems that for some reason they execute code in parallel to EXIT_BOOT_SERVICES, which results in SATA controller being inaccessible from macOS. A better approach should be found in some future. Expect 3-5 seconds to be enough in case the quirk is needed."; ObjectID = "yXm-Kd-A6O"; */
"yXm-Kd-A6O.ibShadowedToolTip" = "Vous pouvez contourner le message \n Toujours en attente du périphérique racine\n qui apparaît sur le micrologiciel APTIO IV sélectionné, c'est-à-dire ASUS Z87-Pro, en particulier lorsque vous utilisez FileVault 2. Pour une raison quelconque, le contrôleur SATA n'est pas accessible à partir de macOS. Une meilleure approche devrait être trouvée à l'avenir. Si vous l'utilisez, vous devez le régler pendant 3 à 5 secondes. \n Généralement, conservez la valeur par défaut de 0, ne la modifiez pas par hasard!";

/* Class = "NSButtonCell"; title = "IgnoreTextInGraphics"; ObjectID = "ygR-oy-xAC"; */
"ygR-oy-xAC.title" = "IgnoreTextInGraphics";

/* Class = "NSButtonCell"; title = "ReconnectOnResChange"; ObjectID = "zen-LP-Fan"; */
"zen-LP-Fan.title" = "ReconnectOnResChange";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some firmwares block partition handles by opening them in By Driver mode, which results in File System protocols being unable to install.\nNote: The quirk is mostly relevant for select HP laptops with no drives listed."; ObjectID = "zhZ-UN-ASB"; */
"zhZ-UN-ASB.ibShadowedToolTip" = "Les ordinateurs portables HP sont définis sur OUI lorsqu'il n'y a pas d'entrée de démarrage dans l'interface de démarrage OpenCore";
